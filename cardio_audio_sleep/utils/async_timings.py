import numpy as np
from numpy.typing import ArrayLike, NDArray

from ._checks import check_type, ensure_int


def generate_async_timings(
    sequence_timings: ArrayLike,
    perc: float = 10.0,
    n: int | None = None,
) -> NDArray[float]:
    """Generate timings for an asynchronous block from a synchronous block.

    Given the sequence of timings of a synchronous block, generate the sequence
    of timings for the future asynchronous block(s).
    The 10% top and bottom timings are removed and the asynchronous timing
    sequence is generated by randomizing the remaining synchornous
    inter-stimuli timings.

    Parameters
    ----------
    sequence_timings : list | tuple | array
        List of timings at which an R-peak occurred.
    perc : float
        Bottom and top percentage of timings removed.
    n : int | None
        Number of stimulus (timings) in the asynchronous condition. If None,
        uses the number of timings in 'sequence_timings'.

    Returns
    -------
    sequence_timings : array
        List of timings at which a stimuli occurs for the asynchronous blocks.
    """
    check_type(sequence_timings, (list, tuple, np.ndarray), "sequence_timings")
    check_type(perc, ("numeric",), "perc")
    if n is not None:
        n = ensure_int(n, "n")
    if perc < 0 or 50 <= perc:
        raise ValueError(
            "Argument 'perc' should represent a percentage "
            f"between 0 and 50. Provided '{perc}'% is not "
            "valid."
        )
    if n is not None and n <= 0:
        raise ValueError("Argument 'n' should be a strictly positive integer.")

    # remove bottom and top perc%
    n = len(sequence_timings) if n is None else n
    diff = np.diff(sequence_timings)
    mask = np.where(
        (np.percentile(diff, perc) <= diff) & (diff <= np.percentile(diff, 100 - perc))
    )
    assert diff[mask].size != 0

    # generate sequence of 'n-1' valid inter-stimulus delays
    delays = np.random.choice(diff[mask], size=n - 1, replace=True)
    timings = np.zeros((n,))
    for k, delay in enumerate(delays):
        timings[k + 1] = timings[k] + delay
    return timings


def generate_async_timings_based_on_mean(
    sequence_timings: ArrayLike,
    n: int | None = None,
) -> NDArray[float]:
    """Generate timings for an asynchronous block from a synchronous block.

    Given the sequence of timings of a synchronous block, generate the sequence
    of timings for the future asynchronous block(s).
    Any inter-stimuli  delay above and below 0.5 times the mean are removed and
    the asynchronous timing sequence is generated by randomizing the remaining
    synchornous inter-stimuli timings.

    Parameters
    ----------
    sequence_timings : list | tuple | array
        List of timings at which an R-peak occurred.
    n : int | None
        Number of stimulus (timings) in the asynchronous condition. If None,
        uses the number of timings in 'sequence_timings'.

    Returns
    -------
    sequence_timings : array
        List of timings at which a stimuli occurs for the asynchronous blocks.
    """
    check_type(sequence_timings, (list, tuple, np.ndarray), "sequence_timings")
    if n is not None:
        n = ensure_int(n, "n")
    if n is not None and n <= 0:
        raise ValueError("Argument 'n' should be a strictly positive integer.")

    # remove bottom and top perc%
    n = len(sequence_timings) if n is None else n
    diff = np.diff(sequence_timings)
    mean = np.mean(diff)
    mask = np.where((diff < 1.8 * mean) & (0.2 * mean < diff))
    assert diff[mask].size != 0

    # generate sequence of 'n-1' valid inter-stimulus delays
    delays = np.random.choice(diff[mask], size=n - 1, replace=True)
    timings = np.zeros((n,))
    for k, delay in enumerate(delays):
        timings[k + 1] = timings[k] + delay
    return timings
